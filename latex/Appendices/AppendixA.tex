% Appendix A

\chapter{Tecnico} % Main appendix title

\label{AppendixA} % For referencing this appendix elsewhere, use \ref{AppendixA}


\subsection{Authentication}

L'autenticazione dei peer avviene effettuando il sign (o calcolando il MAC) di un payload che dipende dagli scambi precedenti.
In particolare questo payload è cmposto da un ottetto che viene autenticato in base alla modalità di aunteticazione scelta:

\begin{itemize}
    \item Nel caso di \textit{PubKey} questo viene firmato con la chiave privata del peer e ne viene allegato il certificato della chiave pubblica 
    \item Nel caso di \textit{PSK} l'AUTH payload viene generato a partire dalla chiave condivisa a cui viene aggiunge della unpredicability tramite del padding e una prf
\end{itemize}

\section{Key Derivation}

\subsection{IKE SA}

Le chiavi in una IKE SA vengono derivate a partire dagli attributi dei dirrenti scambi.
In particolare al termine del primo scambio viene calcolato il:

$$SKEYSEED=PRF(N_i|N_r,g^{ir})$$

A partire da questo sidder vengono generati i prametri di sicurezza da utililizzare per la IKE SA, questi sono derivati nel seguente modo:

$$\{SK_{d} | SK_{ai} | SK_{ar} | SK_{ei} | SK_{er} | SK_{pi} | SK_{pr} \} = PRF+(SKEYSEED, N_i|N_r, SPI_i, SPI_r)$$

\begin{table}[htbp]
    \centering
    \begin{tabular}{ll}
        \toprule
        \textbf{Chiave} & \textbf{Descrizione} \\
        \midrule
        $SK_d$ & Utilizzata per generare il keymaterial per le CHILD\_SA \\
        $SK_{a}$ & Chiavi per autenticare gli scambi successivi, una per direzione \\
        $SK_{e}$ & Chiavi per cifrare gli scambi successivi, una per direzione \\
        $SK_{p}$ & Chiavi utilizzata per generare l'AUTH Payload, una per direzione \\
        \bottomrule
    \end{tabular}
    \caption{Chiavi e loro utilizzo}
\end{table}

\subsection{IPsec SA}

Nel caso di una SA questa può essere generata automaticamente dopo l'auth oppure attraverso l'apposito scambio di questo tipo il keymaterial a partire dal quale vengono derivati i parametri di sicurezza è ottenuto nel seguente modo:

$$KEYMAT=prf+(SK_d,  N_i|N_r)$$

Nel caso in cui invece si utilizza lo scambio apposito il key material è ottenuto nel seguente modo


\section{Security Association Payload}

Il Security Association Payload denotato con $SA$ è utlilizzatoper negoziare gli attributi di una Secuiry Association. 
Dunque può contenere molteplici proposte, le quali devono essere ordinate per preferenza, ogni proposal contiene i seguenti algoritmi crittografici:

\begin{itemize}
    \item Encryption Algorithm (ENCR)
    \item Preudorandom Function (PRF)
    \item Integrity Algorithm (INTEG)
    \item Diffie-Hellman Group (KE)
    \item PQ KEM 
\end{itemize}



\newpage

\section{Docker}

Il dockerfile in cui andiamo a containerizzare il servizio è quello in, riferimento al file.
A partire da un'immagine ubuntu andiamo ad installare tutte le utility necessarie, dopodichè 
si scarica il sorgenti di oqs e si compila con i parametri specificati.
Si fa la stessa cosa per strongswan e in fase di confiugrazione si specificano i parametri.
Infine si fa un clean-up del sistema dalle dipendenze necessarie solo per la compilazione.

\begin{lstlisting}[language=Dockerfile]

FROM ubuntu:22.04
RUN DEV_PACKAGES="wget unzip bzip2 make gcc libssl-dev cmake ninja-build"
RUN apt-get update 
    && apt-get install -y iproute2 iputils-ping nano $DEV_PACKAGES 
    && mkdir /liboqs && cd /liboqs 
    && wget linksourcecodeliboqs\$LIBOQS\_VERSION.zip 
    && unzip $LIBOQS_VERSION.zip && cd liboqs-$LIBOQS_VERSION 
    && mkdir build && cd build &&
    && cmake -GNinja -DOQS_USE_OPENSSL=ON \
        -DBUILD_SHARED_LIBS=ON \
        -DCMAKE_INSTALL_PREFIX=/usr \
        -DCMAKE_BUILD_TYPE=Release \
        -DOQS_BUILD_ONLY_LIB=ON .. 
    && ninja && ninja install 
    && cd / && rm -R /liboqs 
    && mkdir /strongswan-build && cd /strongswan-build 
    && wget linksourcecode/strongswan-$VERSION.tar.bz2 
    && tar xfj strongswan-$VERSION.tar.bz2 && cd strongswan-$VERSION 
    && ./configure --prefix=/usr
        --sysconfdir=/etc 
        --disable-ikev1 
        --enable-frodo 
        --enable-oqs
        --enable-silent-rules 
    && make all && make install 
    && cd / && rm -R strongswan-build 
    && ln -s/usr/libexec/ipsec/charon charon 
    && apt-get -y remove \$DEV\_PACKAGES 
    && apt-get -y autoremove && apt-get clean 
    && rm -rf /var/lib/apt/lists/*
EXPOSE 500 4500
ENTRYPOINT ["./charon" ]
\end{lstlisting}

\noindent
Le opzioni \texttt{cap\_add} sono utilizzate per aggiungere capacità specifiche ai container
Docker, consentendo loro di eseguire operazioni che normalmente richiederebbero
privilegi di root. Queelli che servono per il nostr setup sono:

\begin{itemize}
    \item \texttt{NET\_ADMIN} consente al processo all'interno del
    container di eseguire operazioni di amministrazione della rete. 
    Fondamentale per configurare le interfacce di rete e gestire il routing e i
    firewall, operazioni chiave per VPN e IPsec.
    \item \texttt{SYS\_MODULE} consente di caricare e scaricare moduli
    del kernel. Fonda\-mentale per caricare moduli del kernel per supportare 
    funzionalità IPsec che non sono già caricate.
    \item \texttt{SYS\_ADMIN} è una delle capacità più potenti e può
    consentire una vasta gamma di operazioni di amministrazione del sistema.

\end{itemize}

\begin{lstlisting}[style=yaml]
    services: 
        moon: 
            build: ./ 
            container_name: moon 
            cap_add: 
                - NET_ADMIN 
                - SYS_ADMIN 
                - SYS_MODULE 
            volumes: 
                - ./moon:/etc/swanctl 
                - ./strongswan.conf:/etc/strongswan.conf 
        
        carol: 
            build: ./ 
            container_name: carol 
            depends_on: 
                - moon 
            cap_add: 
                - NET_ADMIN 
                - SYS_ADMIN 
                - SYS_MODULE 
            volumes: 
                - ./carol:/etc/swanctl 
                - ./strongswan.conf:/etc/strongswan.conf 
    
\end{lstlisting}

\section{Certificati}

Strongswan mette a disposizione un'utility \texttt{pki} per la gestione della public key infrastrucutre.
Tramite questa utility siamo andati a generare i certificati che serviranno poi per la fase di
mutua autenticazione tra i due peer.
\todo{Vai a vedere su E14 per le dimensioni}
Andiamo a confrontarne la dimensione:
\begin{table}[h]
    \centering
    \begin{tabular}{lcc}
        \toprule
        \textbf{Schema} & \textbf{Chiave private} & \textbf{Certificato} \\
        \midrule
        \texttt{ECDSA} & 227 & 530 \\
        \texttt{falcon512} & 3.0k & 2.4k\\
        \texttt{falcon1024} & 5.6k & 4.5k\\
        \texttt{dilithium2} & 5.3k & 5.4k\\
        \texttt{dilithium3} & 8.2k & 7.6k\\
        \texttt{dilithium5} & 10k & 10k\\
    \end{tabular}
\end{table}
    
Riportare i comandi per generare i certificati e la firma del CA su quelli dei peer
Spiegare che più la catena di certificati diventa lunga più è lungo il processo di autenticazione
e maggiori saranno le dimensioni dei certificati


Per generare una certificato di chiave pubblico Root utilizzare i seguenti comandi:
\begin{lstlisting}
    pki --gen --type falcon1024 --outform pem > CA.type.pem 
    pki --self --type priv --in CA.type.pem 
        --ca 
        --lifetime 3652 
        --dn "CN=CA-Dilithium5"
        --outform pem > CA.type.cert.pem
\end{lstlisting}

Per utilizzarlo per firmare la chiave pubblica di qualcun'altro utilizzare il 
seguente comando:
\begin{lstlisting}
    pki --issue 
        --cacert CA.dilithium5.cert.pem 
        --cakey CA.dilithium5.pem 
        --type priv --in Moon.dilithium5.pem 
        --lifetime 1461 
        --dn "CN=moon.dilithium5"
        --outform pem > Moon.dilithium5.cert.pem
\end{lstlisting}

