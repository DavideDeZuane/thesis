% Chapter Template

\chapter{Scenario} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\textit{In questo capitolo facciamo un introduzione su quello che è lo scenario che stiamo considerando per il nostro lavoro: 
quello delle comunicazioni satellitare. Vediamo nel dettaglio quali sfide introduce, le tecnologie utilizzate 
e come affrontare le possibile problematiche a causa di applicare la PQC.}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Comunicazioni Satelliari}


Le comunicazioni satellitari sono fondamentali per le infrastrutture moderne, poichè abilitano una vasta gamma di servizi.
Negli ultimi decenni, con l'aumento della domanda di connettività globale e l'espansione delle reti di comunicazione, i satelliti sono diventati strumenti essenziali per garantire una copertura estesa.
L'emergere delle costellazioni di satelliti in orbita bassa (LEO - Low Earth Orbit) sta cambiando il paradigma delle comunicazioni satellitari, offrendo vantaggi significativi rispetto ai satelliti geostazionari (GEO), un confronto tra le due orbite è mostrato in \textit{Figura \ref{fig:orbite}}. 
%Mentre i satelliti GEO forniscono una copertura stabile, i satelliti LEO consentono Round Time Trip (RTT) notevolmente ridotti e una maggiore flessibilità, rendendoli ideali per applicazioni ad alta velocità come la trasmissione dati in tempo reale e la connettività Internet globale.
\todo{Scrivere meglio questa parte finale}
Questo cambio di paradigma insieme al quantum computer hanno portato diversi enti, tra cui l'Agenzia Spaziale Europea (ESA), ad affrontare nuove sfide.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        % Definizione dei colori per le orbite
        \definecolor{leo}{gray}{0.2}    % Grigio scuro
        \definecolor{geo}{gray}{0.1}% Grigio molto scuro
        \definecolor{terra}{HTML}{008F39}
        \definecolor{mare}{HTML}{0495ce}
        \node at (-4.8, 0) [color=geo]{GEO};
        \node at (3.5, 0) [color=leo]{LEO};
        \node at (0, 0) {Terra};
        
        \draw[thick, dashed, geo] (0,0) circle (4.2cm);
        \draw[thick, dashed, leo] (0,0) circle (3cm);
        \filldraw[fill=mare,] (0,0) circle (2.2cm);

        \path[draw, decoration={text along path, text={$2.000km$}, text align=center}, decorate] (0,0) (180:2.8cm) arc (180:360:2.8cm);
        \path[draw, decoration={text along path, text={$36.000km$}, text align=center}, decorate] (0,0) (180:4cm) arc (180:360:4cm);

        \node at (-2.5,2) {\includegraphics[width=1cm]{Figures/satellite.png}}; % Sostituisci 'your_image.png' con il percorso della tua immagine
        \node at (3.2,3) {\includegraphics[width=1cm, angle=270]{Figures/satellite.png}}; % Sostituisci 'your_image.png' con il percorso della tua immagine
        \node at (0.2,0.5) {\includegraphics[width=3cm ]{Figures/europe.png}}; % Sostituisci 'your_image.png' con il percorso della tua immagine

        \node[cloud, cloud puffs=15.7, cloud ignores aspect, minimum width=1.5cm, minimum height=0.5cm, align=center, fill=white, draw] (cloud) at (-2, 0) {};
        \node[cloud, cloud puffs=15.7, cloud ignores aspect, minimum width=1.5cm, minimum height=0.5cm, align=center, fill=white, draw] (cloud) at (2, -0.5) {};

    \end{tikzpicture}
    \caption{Orbite dei satelliti}
    \label{fig:orbite}
\end{figure}

\subsection{Limitazioni}

L'ambiente spaziale, caratterizzato da radiazioni intense, temperature estreme e lunghi periodi senza manutenzione, pone sfide significative in termini di progettazione e operatività dell'hardware e del software.
Tra i principali vincoli per l'hardware satellitare troviamo:

\begin{itemize}
    \item \textit{Resistenza alle radiazioni}: i componenti elettronici sono progettati per resistere all'esposizione costante alle radiazioni spaziali.
    \item \textit{Basso consumo energetico}: l'energia disponibile per le operazioni risulta limitata, quindi si usano processori a basso consumo e ad alta efficienza energetica, sacrificando potenza di calcolo.
    \item \textit{Elaborazione in tempo reale}: per alcune tipologie di servizi è necessario che il processamento avvenga in tempo reale.
    \item \textit{Compattezza}: a causa dello spazio limitato a bordo di un satellite, i componenti hardware devono essere progettati in modo estremamente compatto.
\end{itemize}

\noindent
L'hardware limitato ha un impatto diretto sullo sviluppo del software per i satelliti. 
Rispetto al contesto terrestre, dove le risorse computazionali sono abbondanti, il software per i satelliti deve essere ottimizzato per funzionare su processori con bassa potenza di calcolo e memoria ridotta. 
Le principali sfide per gli sviluppatori sono:

\begin{itemize}
    \item \textit{Semplicità e ottimizzazione}: gli algoritmi devono essere semplici e ottimiz\-zati per funzionare su hardware con risorse limitate.
    \item \textit{Parallelismo limitato}: le operazioni devono essere eseguite in modo lineare o con limitato parallelismo, aumentando la complessità della progettazione.
    \item \textit{Affidabilità assoluta}: il software deve essere robusto, sicuro e testato ampiamente in modo tale che possibile errori non abbiano conseguenza catastrofiche.
\end{itemize}

\noindent
È fondamentale prestare particolare attenzione alle implementazioni 
crittogra\-fiche dato che in contesto come questo, risulta cruciale trovare un equilibrio tra
sicurezza e prestazioni. Da un lato, è necessario proteggere le comunicazioni
utilizzando algoritmi crittografici complessi; dall'altro, è essenziale
garantire che le operazioni eseguite non compromettano l'operatività del
satellite.

\subsection{Stato Attuale}

Per capire quale è la differenza in termini di hardware e software rispetto a quelli a cui siamo abituati 
introduciamo quelli che sono gli attuali standard impiegati in questo settore.

\begin{itemize}
    \item Tra i processori utilizzati abbiamo \textit{LEON3}, un processore open-source basato sull'architettura SPARC, progettato dall'ESA. 
    \item ESA Power Interface Standard (ECSS-E-ST-20C): definisce come deve avvenire la distribuituzione dell'alimentazione elettrica all'interno dei satelliti.
    \item Cubesat Standard: definisce dimensioni compatte modulari (10x10x10 cm per 1U) per ridurre i costi e semplificare il lancio e la costruzione dei satelliti.
    \item Triple Modular Redundancy (TMR): nei sistemi critici spaziali si utilizza la ridondanza tripla modulare, per garantire l'affidabilità dei risultati tramite sistemi di voting.
\end{itemize}
\noindent
Il sistema operativo utilizzato in queste applicazioni è RTEMS (Real-Time Executive for Multiprocessor Systems) che le caratteristiche di essere open-source, real-time e basato su GNU/Linux.
\todo{se si trova riportare qualche riferimento}

%-----------------------------------
%	SECTION 2
%-----------------------------------
\subsection{Sfide}
\noindent
Per rendere le comunicazioni satellitari sicure ad attacchi quantum occorre adottare algoritmi più complessi.
Tuttavia, oltre a richiedere più memoria per la gestione delle chiavi,
comportano un incremento significativo del carico di calcolo. Le sfide da affrontare sono:

\begin{itemize}
    \item Aumento complessità computazionale: l'incremento delle dimensioni delle chiavi e della complessità degli algoritmi portano a un aumento del carico computazionale. Aggiungendo ulteriori vincoli su sistemi già limitati. 
    \item Incremento della larghezza di banda necessaria: oltre all'aumento di carico si ha anche maggiore utilizzo della larghezza di banda, che in comunicazioni satellitari risuta già limitata.
    \item Compatibilità retroattiva: occorre adottare soluzioni ibride, in cui
    algo\-ritmi crittografici classici coesistono con quelli post-quantum. Questo a 
    causa dell'eterogeneità delle capacità dei satelliti in orbita.
\end{itemize}

\section{Benchmarking}

\todo{riformula}
Per valutare l'applicabilità degli algoritmi di PQC
nel contesto satellitare, è fondamentale comprendere il loro impatto sui
protocolli di comunicazione. Inizialmente, analizzeremo tali algoritmi in un
ambiente desktop confrontan\-doli con quelli classici per evidenziare eventuali
differenze. Se le discrepanze risultano già significative nel contesto simulato,
sarà poco sensato considerarli in un ambiente ancora più limitato.


\subsection{Ambiente}

\begin{comment}
    L'ambiente di test, descritto in \textit{Tabella \ref{tab:env}}, è stato progettato in modo da isolare i singoli servizi all'interno di
    container, facilitando l'analisi del carico e delle risorse consumate da ciascuno di questi. 
\end{comment}

Il protocollo che consideriamo è IPsec, con un focus particolare sulla sua
implementazione in StrongSwan. L'implementazione delle primitive post-quantum è fornita dalla libreria \texttt{liboqs}. 
Questa fa parte del progetto open-source \textit{OpenQuantumSafe} (OQS).
Il quale punta a rendere disponibile l'infrastruttura crittografica necessaria per proteggere i sistemi informatici
dall'avvento dei computer quantistici. L'obiet\-tivo del progetto è quello di fornire:

\begin{itemize}
    \item API standardizzate per supportare lo scambio chiavi e la firma digitale. 
    \item Modularità, facilitando l'aggiunta di nuovi algoritmi. 
    \item Prestazioni ottimizzate per diverse architetture hardware.
\end{itemize}

\noindent
Si tratta di una raccolta di implementazioni di algoritmi crittografici post-quantum, KEM e SIG, e strumenti per integrarli in protocolli di sicurezza esistenti per sperimentare e testare il loro impatto.
In \textit{Tabelle \ref{tab:env}} è presente una descrizione dettagliata dell'ambiente utilizzato per fare i test.

\begin{table}[htbp] 
    \centering 
    \begin{tabular}{p{4cm} p{8cm}} 
        \toprule
        \textbf{Componente} & \textbf{Descrizione} \\ 
        \midrule
        \textbf{Hardware} & \\ 
        CPU & Ryzen 7-5825U (8 core, 3.8 GHz) \\ 
        RAM & 24 GB DDR4 \\ 
        Storage & 1024 GB SSD NVMe \\ 
        \textbf{OS} & \\ 
        Distribuzione & Arch Linux \\
        Kernel & Linux 6.10.10-arch1-1 \\ 
        \textbf{Software} & \\ 
        Linguaggio & Bash Script \\
        Strongswan & 6.0.0beta Post-Quantum IKEv2 Daemon \\
        liboqs & Version 0.9.2 \\
        Docker & Version 24.0.6 \\ 
        \hline 
    \end{tabular} 
    \caption{Descrizione dell'ambiente di test virtualizzato} 
    \label{tab:env}
\end{table}



\subsection{Metodologia}

Per ragioni progettuali e di portabilità del codice, il servizio Strongswan è stato 
containerizzato tramite l'utilizzo di Docker. Ciò consente di avere due istanze dello stesso
servizio in esecuzione in grado di comunicare attaverso un'interfaccia virtuale. 

\begin{center}
    \begin{verbatim}
            +-------+                         +--------+ 
            | carol | === Virtual Interf. === |  moon  |
            +-------+                         +--------+ 
    \end{verbatim}
\end{center}

\noindent
In secondo luogo siamo andati a definire quali sono le configurazioni da confrontare, riportate in 
\textit{Tabella \ref{tab:cipher_suites}}, ognuna delle quali è caratterizzata da:

\begin{itemize}
    \item \textbf{Chiper suite}: un insieme di algoritmi crittografici che determinano la sicurezza di una connessione in un protocollo di rete.
    Le cipher suite sono generalmente denominate seguendo una convenzione di naming standardizzata che riflette i componenti inclusi nella suite.
    \begin{center}
        \texttt{<ENCR>\text{-}<INTEG>\text{-}<KEM>}
    \end{center}

    \item \textbf{Authentication Method}: sono supportati diverse modalità di autentica\-zione, tuttavia noi vogliamo vedere
    come si comportano gli schemi di firma post-quantum. Per questo motivo utilizzeremo l'autenticazione mediante 
    certificati. \todo{rimandare in appendice per il concetto di chain e root}
\end{itemize}

\noindent
Nella nostra analisi, abbiamo scelto tre configurazioni distinte per le cipher
suite, ognuna progettata per affrontare specifici aspetti delle tecnologie
critto\-grafiche attuali e future.

\noindent
La prima configurazione utilizza esclusivamente \textit{primitive classiche}. 
Questa scelta rappresenta il benchmark attuale delle tecnologie di crittografia e fornisce una base
solida per confrontare le altre configurazioni. La seconda
configurazione è composta da \textit{primitive post-quantum}, e consente di
analizzare le prestazioni e l'efficacia delle soluzioni crittografiche
post-quantum nel contesto del protocollo. Infine, abbiamo implementato
una \textit{configurazione Ibrida}, la quale combina elementi delle primitive
classiche e post-quantum. Questa scelta è progettata per garantire la transizione 
graduale verso l'utilizzo esclusivo di tecnologie quantum-resistant.

\begin{comment}
    
    \begin{itemize}
    \item \textit{Configurazione Classica}: questa scelta rappresenta il benchmark attuale delle tecnologie
    di crittografia e fornisce una base solida per confrontare le altre configurazioni.
    \item \textit{Configurazione PQ}: questa configurazione permette di
    analizzare le pres\-tazioni e l'efficacia delle soluzioni crittografiche
    post-quantum nel conte\-sto del protocollo.
    \item \textit{Configurazione Ibrida}: questa configurazione è progettata
    per garantire una transizione verso il solo utilizzo di tecnologie
    quantistiche. 
\end{itemize}
\end{comment}

\renewcommand{\arraystretch}{1.2}
\todo{gli altri algoritmi tipo hqc, bike,...}
\begin{table}[h]
    \centering 
    \begin{tabular}{cll} 
        \toprule
        \textbf{Name} & \textbf{Chiper Suites} & \textbf{Firma Digitale}\\ 
        \midrule 
        \texttt{A1} & \texttt{aes128ctr\text{-}sha256\text{-}ecp256} & \texttt{ECDSA}         \\          
        \texttt{B1} & \texttt{aes128ctr\text{-}sha256\text{-}kyber1} & \texttt{dilithium2}                 \\ 
        \texttt{C1} & \texttt{aes128ctr\text{-}sha256\text{-}ecp256\text{-}ke1\_kyber1} & \texttt{falcon512} \\ 
        \hline
        \texttt{A3} & \texttt{aes192ctr\text{-}sha384\text{-}ecp384}         &  \texttt{ECDSA}        \\ 
        \texttt{B3} & \texttt{aes192ctr\text{-}sha384\text{-}kyber3}          &  \texttt{dilithium3}      \\ 
        \texttt{C3} & \texttt{aes192ctr\text{-}sha384\text{-}ecp384\text{-}ke1\_kyber3} & \texttt{falcon1024} \\
        \hline
        \texttt{A5} & \texttt{aes256ctr\text{-}sha512\text{-}ecp521}              &  \texttt{ECDSA}    \\ 
        \texttt{B5} & \texttt{aes256ctr\text{-}sha512\text{-}kyber5}               &  \texttt{dilithium5}   \\ 
        \texttt{C5} & \texttt{aes256ctr\text{-}sha512\text{-}ecp521\text{-}ke1\_kyber5} & \texttt{falcon1024} \\  
        \hline
    \end{tabular}
    \caption{Cipher Suites suddivise per Livello di Sicurezza} 
    \label{tab:cipher_suites} 
\end{table}


\noindent
Il testing viene realizzato attraverso uno script Bash. Nella Figura 3.2 è
illustrata la struttura dei file necessari per automatizzare l'intero processo,
consentendo così un'operazione completamente "zero-touch", che riduce al
minimo l'intervento manuale.
Tra questi abbiamo:

\todo{dire di fare riferimento in appendice?}

\begin{itemize}
    \item \texttt{Dockerfile}: a partire da un'immagine Ubuntu si installa il servizio StrongSwan e si integra la libreria liboqs.
    \item \texttt{docker-compose}: consente di orchestrare i due container, in cui si specifi\-cano volumi e parametri di connessione tra i due.
\end{itemize}
\noindent
Ad ogni container è associato a un volume, identificato con il proprio
nome, che contiene le configurazioni specifiche (connessioni e certificati) per il daemon.
Questa struttura facilita la modifica e il testing delle diverse configu\-razioni
senza influenzare l'altro container, contribuendo a un ambiente di test più
controllato e flessibile.

\noindent
Per automatizzare il processo di testing e garantire un'esecuzione efficiente, è
stato sviluppato uno script in Bash che gestisce l'intero flusso operativo.
Questo script si basa esclusivamente su utility integrate di Linux, eliminando
la necessità di installare software aggiuntivo. Esso non solo avvia i container
e configura i parametri necessari, ma si occupa anche della raccolta e
dell'analisi dei risultati. In \textit{Figura \ref{fig:flow}} è riportato il suo diagramma di flusso
in particolare le principali fasi.
\todo{dire di fare riferimento all'appendice per una descrizione dettagliata}
\todo{descrivere quelli che sono i principali tool utilizzati?}


\begin{figure}
    \dirtree{% 
    .1 /. 
    .2 \textcolor{blue}{carol}. 
    .3 \textcolor{blue}{conn}. 
    .3 swanctl.conf. 
    .3 \textcolor{blue}{x509}. 
    .3 \textcolor{blue}{x509ca}. 
    .2 \textcolor{green!80}{docker-compose.yml}. 
    .2 Dockerfile. 
    .2 \textcolor{blue}{moon}. 
    .3 \textcolor{blue}{conn}. 
    .3 swanctl.conf. 
    .3 \textcolor{blue}{x509}. 
    .3 \textcolor{blue}{x509ca}. 
    .2 strongswan.conf. 
    .2 \textcolor{green!90}{strongswan.sh}. 
    }
    \caption{Struttura delle directory}
    \label{fig:tree}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[node distance=2cm, scale=0.8]
        % Definizione dei blocchi 
        \tikzset{
            customnode/.style={rectangle, draw, minimum width=3cm, minimum height=1cm, inner sep=5pt},
            decisionnode/.style={diamond, draw, aspect=2, minimum width=3cm, inner sep=5pt}
        }
        \node (start)  [customnode, rounded corners] {Inizio}; 
	    \node (param1) [customnode, left=of start] {Conn: <nome>}; 
	    \node (param2) [customnode, right=of start] {Iterazioni: <num>}; 
        \node (docker) [below of=start, customnode] {Avvio ambiente}; 
        \node (config) [below of=docker, customnode] {Avvio della Conn};
        \node (sniff)  [below of=config, customnode] {Sniffing su interfaccia virtuale}; 
        \node (parsing)  [below of=sniff, customnode] {Parsing pacchetti e tempi}; 
        \node (condition) [below of=parsing, decisionnode] {Iterazioni=0}; 
        \node (result)  [below of=condition, customnode] {Stampa dei risultati}; 
        \node (end) [customnode, rounded corners, below of=result] {Fine};
        \draw [-, dashed] (param1) -- (start); 
        \draw [-, dashed] (param2) -- (start); 
        \draw [->] (start) -- (docker); 
        \draw [->] (docker) -- (config); 
        \draw [->] (config) -- (sniff);     
        \draw [->] (sniff) -- (parsing); 
        \draw [->] (parsing) -- (condition); 
        \draw [->] (condition) -- node[right]{Sì} (result);
        \draw [->] (result) -- (end);
        \draw [->, rotate=270] (condition.east) -- node[above]{No} ++(0,4)  -| (config.east);
    \end{tikzpicture}
    \caption{Diagramma di flusso dello script}
    \label{fig:flow}
\end{figure}

\subsection{Risutlati}

Le principali metriche di interesse per il nostro studio sono state selezionate
con l'obiettivo di valutare l'overhead introdotto dall'adozione
delle nuove primitive crittografiche influenzi aspetti chiave come l'efficienza
della comuni\-cazione e la sicurezza. Queste sono:

\begin{itemize}
    \item \textit{Tempo Complessivo} per stabilire la SA tra i due, il tempo di elabora\-zione del singolo algoritmo non ci interessa poichè ampiamente descritto
    dalla libreria openquantumsafe.   
    \item \textit{Packet Size} che rappresenta la quantità di dati necessaria affinchè i due nodi siano in grado 
    di stabilire una Security Association (SA).
\end{itemize}

\noindent
In \textit{Tabella \ref{tab:result}} sono riportati i risultati delle simulazioni per ciascuna
configu\-razione. Abbiamo preso in esame le principali metriche per ogni fase di
scambio del protocollo, permettendo così un confronto più dettagliato tra le
varie configurazioni. Inoltre, per ciascuno scambio è stata fatta una
distinzione tra le operazioni dell'initiator e quelle del responder.

\noindent
Le metriche riportate sono state ottenute iterando il processo di connessione 50
volte, mediando così i risultati per un'analisi più accurata delle prestazioni.\\

\noindent
Nell'analisi che segue, lo scambio intermediate, sebbene riportato separa\-tamente
nella tabella, è considerato parte integrante del processo di \texttt{INIT}. Infatti,
questo scambio viene utilizzato sia per trasmettere dati che non rientrano nel
primo scambio, sia per effettuare un KEM post-quantum, il quale è comunque parte
del processo di \texttt{INIT}.\\

\begin{table}[h!] 
    \centering 
    \begin{tabular}{clrrc} 
        \toprule
        \multirow{2}{*}{\textbf{Connessione}} & \multirow{2}{*}{\textbf{Scambio}} & \multicolumn{2}{c}{\textbf{Dati Trasferiti (Byte)}} & \multirow{2}{*}{\textbf{Tempo (ms)}} \\
        \cline{3-4} & & \textbf{Inviati} & \textbf{Ricevuti} \\
        \toprule
        \multirow{3}{*}{A1} & \texttt{INIT} & 326 & 334 & 1.102 \\ 
                            & \texttt{INTE} & - & - & - \\
                            & \texttt{AUTH} &  632 & 570 & 0.977 \\ 
        \hline
        \multirow{3}{*}{B1} & \texttt{INIT} & 1062 & 1038 & 0.982 \\ 
                            & \texttt{INTE} & - & - & - \\
                            & \texttt{AUTH} & 6665 & 6663 & 1.1583 \\ 
        \hline
        \multirow{3}{*}{C1} & \texttt{INIT} & 342 & 350 & 0.709 \\ 
                            & \texttt{INTE} & 911 & 879 & 0.912 \\
                            & \texttt{AUTH} & 2623 & 2591 & 1.000 \\ 
        \hline
        \multirow{3}{*}{A3} & \texttt{INIT} & 358 & 366 & 1.407 \\ 
                            & \texttt{INTE} & - & - & - \\
                            & \texttt{AUTH} & 638 & 578 & 1.486 \\ 
        \hline
        \multirow{3}{*}{B3} & \texttt{INIT} & 1446 & 1358 & 0.767 \\ 
                            & \texttt{INTE} & - & - & - \\
                            & \texttt{AUTH} & 9210 & 9180 & 1.402 \\ 
        \hline
        \multirow{3}{*}{C3} & \texttt{INIT} & 374 & 382 & 1.642 \\ 
                            & \texttt{INTE} & 1303 & 1207 & 2.488 \\
                            & \texttt{AUTH} & 4845 & 4831 & 1.210 \\ 
        \hline
        \multirow{3}{*}{A5} & \texttt{INIT} & 394 & 402 & 1.181 \\ 
                            & \texttt{INTE} & - & - & - \\
                            & \texttt{AUTH} & 646 & 587 & 1.805 \\ 
        \hline
        \multirow{3}{*}{B5} & \texttt{INIT} & 1514 & 1514 & 0.887 \\ 
                            & \texttt{INTE} & 350 & 358 & 1.672 \\
                            & \texttt{AUTH} & 12501 & 12471 & 1.303 \\ 
        \hline
        \multirow{3}{*}{C5} & \texttt{INIT} & 410 & 418 & 1.108 \\ 
                            & \texttt{INTE} & 1729 & 1729 & 1.672 \\
                            & \texttt{AUTH} & 4856 & 4832 & 1.622 \\ 
        \hline
    \end{tabular} 
    \caption{Tabella dei Risultati} 
    \label{tab:result}
        
\end{table}


\newpage 
\subsubsection*{Packet Size}
Dai grafici in \textit{Figura \ref{fig:packet_init} e \ref{fig:packet_auth}}, si nota subito come in fasi 
di autenticazione gli schemi di firma PQ introducano un overhead significativo in termini di dimensione dei certificati 
a causa della lunghezza delle chiavi. 
Mentre nella fase di init l'incremento dovuto al quantum è significativo ma neanche troppo
Oltre a questo c'è anche da considerare il numero di pacchetti necessari ad inviare questi dati, 
dato che un pacchetto IP ha un Payload massimo pari a 1480, ovvero MTU-Payload, se quello che sto 
trasmettendo eccede allora ho la frammentazione.



\begin{figure}[h!] 
    \centering 
    \begin{tikzpicture} 
        \begin{axis}[ 
            width=\textwidth,
            height=8cm, 
            ybar,
            symbolic x coords={Classica, Quantum, Ibrida}, % etichette asse x 
            xtick=data,
            xlabel={},
            ylabel={Dimensione Pacchetti (KByte)}, % Etichetta asse Y 
            nodes near coords,
            bar width=28pt, % larghezza delle barre 
            enlarge x limits={abs=2.3cm}, % spazio tra i gruppi di barre 
            legend pos=north west, %
            ymin=0, % limite inferiore asse Y 
            grid=none,
            %axis line style=none,
    ] % Dati per configurazioni classiche 
            \addplot coordinates {(Classica,0.660) (Quantum,2.100) (Ibrida,2.462)};  %coordinate per le configurazioni L1
            \addlegendentry{L1} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,0.724) (Quantum,3.004) (Ibrida,3.266)}; 
            \addlegendentry{L3} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,0.796) (Quantum,3.736) (Ibrida,4.280)}; 
            \addlegendentry{L5}
        \end{axis} 
    \end{tikzpicture} 
    \caption{KByte totali per \texttt{INIT}}
    \label{fig:packet_init} 
\end{figure}

\begin{figure}[h!] 
    \centering 
    \begin{tikzpicture} 
        \begin{axis}[ 
            width=\textwidth,
            height=8cm, 
            ybar,
            symbolic x coords={Classica, Quantum, Ibrida}, % etichette asse x 
            xtick=data,
            xlabel={},
            ylabel={Dimensione Pacchetti (KByte)}, % Etichetta asse Y 
            nodes near coords,
            bar width=28pt, % larghezza delle barre 
            enlarge x limits={abs=2.3cm}, % spazio tra i gruppi di barre 
            legend pos=north west, %
            ymin=0, % limite inferiore asse Y 
            grid=none,
            yticklabel style={  /pgf/number format/fixed, 
                                /pgf/number format/precision=3, }, 
            scaled y ticks=false,
            %axis line style=none,
    ] % Dati per configurazioni classiche 
            \addplot coordinates {(Classica,1.149) (Quantum,13.228) (Ibrida,5.214)};  %coordinate per le configurazioni L1
            \addlegendentry{L1} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,1.216) (Quantum,18.390) (Ibrida,9.676)}; 
            \addlegendentry{L3} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,1.233) (Quantum,24.972) (Ibrida,9.688)}; 
            \addlegendentry{L5}
        \end{axis} 
    \end{tikzpicture} 
    \caption {KByte totali per \texttt{AUTH}}
    \label{fig:packet_auth} 
\end{figure}

\newpage
\subsubsection*{Tempi}

Notiamo che comunque la confiugrazione più lenta è quella Ibrida
ma questo è normale dato che deve compiere due volte il processo di KEM.

Mentre i tempi allungati per il quantum che altrimenti risulta molto veloce sono 
dovuti in particolare alla frammentazione IP, che quindi richiede un riassemblaggio dei pacchetti.
Continua a descrivere...
Mentre in figura .. e .., riportiamo un confronto tra i tempi, che come possiamo osservare non si discostano molto 
tra di loro.


\begin{figure}[h!] 
    \centering 
    \begin{tikzpicture} 
        \begin{axis}[ 
            width=\textwidth,
            height=8cm, 
            ybar,
            symbolic x coords={Classica, Quantum, Ibrida}, % etichette asse x 
            xtick=data,
            xlabel={},
            ylabel={Tempo (ms)}, % Etichetta asse Y 
            nodes near coords,
            bar width=28pt, % larghezza delle barre 
            enlarge x limits={abs=2.3cm}, % spazio tra i gruppi di barre 
            legend pos=north west, %
            ymin=0, % limite inferiore asse Y 
            grid=none,
            %axis line style=none,
    ] % Dati per configurazioni classiche 
            \addplot coordinates {(Classica,0.966) (Quantum,0.984) (Ibrida,1.621)};  %coordinate per le configurazioni L1
            \addlegendentry{L1} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,1.407) (Quantum,0.765) (Ibrida,4.230)}; 
            \addlegendentry{L3} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,1.175) (Quantum,2.559) (Ibrida,2.780)}; 
            \addlegendentry{L5}
        \end{axis} 
    \end{tikzpicture} 
    \caption{ms totali per \texttt{INIT}}
    \label{fig:tempi_init} 
\end{figure}

\begin{figure}[h!] 
    \centering 
    \begin{tikzpicture} 
        \begin{axis}[ 
            width=\textwidth,
            height=8cm, 
            ybar,
            symbolic x coords={Classica, Quantum, Ibrida}, % etichette asse x 
            xtick=data,
            xlabel={},
            ylabel={Dimensione Pacchetti (KByte)}, % Etichetta asse Y 
            nodes near coords,
            bar width=28pt, % larghezza delle barre 
            enlarge x limits={abs=2.3cm}, % spazio tra i gruppi di barre 
            legend style={ at={(1.1,1)} },
            %legend pos=north west, %
            ymin=0, % limite inferiore asse Y 
            grid=none,
            yticklabel style={  /pgf/number format/fixed, 
                                /pgf/number format/precision=3, }, 
            scaled y ticks=false,
            %axis line style=none,
    ] % Dati per configurazioni classiche 
            \addplot coordinates {(Classica,1.371) (Quantum,1.150) (Ibrida,1.000)};  %coordinate per le configurazioni L1
            \addlegendentry{L1} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,1.486) (Quantum,1.395) (Ibrida,1.210)}; 
            \addlegendentry{L3} % Dati per configurazioni post-quantum
            \addplot coordinates {(Classica,1.804) (Quantum,1.300) (Ibrida,1.622)}; 
            \addlegendentry{L5}
        \end{axis} 
    \end{tikzpicture} 
    \caption {ms totali per \texttt{AUTH}}
    \label{fig:tempi_auth} 
\end{figure}


\section{Osservazioni}
Andiamo a fare il confronto tra l'incremento subito dall'INIT passando da classico a post quantum 
quindi da DH a Kyber e facciamo stessa cosa per l'auth

Per dire che in percentuale la fase di AUTH subisce un overhead molto importante
Stiamo considerando StrongSwan come protocollo, un software noto per la sua
flessibilità e per la disponibilità di numerosi plugin. Tuttavia, in un contesto
limitato come quello dei satelliti, non ha senso portare con sé funzionalità
superflue. Ad esempio, la proposta di suite di crittografia diventa irrilevante
se si conosce già quale suite si intende utilizzare; inviare diverse opzioni
sarebbe superfluo e poco efficiente.

Dai risultati dei nostri test, emerge che non ci sono sostanziali differenze in
termini di tempi di esecuzione. Tuttavia, è stato registrato un significativo
aumento delle dimensioni dei pacchetti, in particolare durante le fasi di
autenticazione, il che risulta problematico in un contesto come quello spaziale,
dove le risorse sono limitate e l'efficienza è fondamentale.

Per affrontare queste sfide, ci siamo imbattuti nel concetto di Minimal IKE,
una versione ottimizzata di IKE progettata per scenari con vincoli di risorse
simili a quelli che si incontrano nello spazio. Tuttavia, va notato che
attualmente non esistono implementazioni concrete di Minimal IKE\@. Pertanto,
abbiamo intrapreso la creazione di una nostra implementazione, con l'obiettivo
di fornire un punto di partenza per questo tipo di scenario.


