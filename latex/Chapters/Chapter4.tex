% Chapter Template

\chapter{Hummingbird} % Main chapter title

\label{ChapterX} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Progettazione}

\subsection{Requisiti}

Nella parte di progettazione portare quelli che sono i requisiti che deve rispettare l'implementazione
sia funzionali che non
uno tra tutto met

\subsection{Architettura}

Archietettura sia delle directory che a livello dei moduli 
Il C richiede una chiara strutturazione per gestire la complessità del codice in modo efficace

\subsubsection*{Moduli}

Per mantenere la separazione dei compiti

\subsubsection*{Strutture Dati}

%-----------------------------------
%	SECTION 2
%-----------------------------------
\section{Implementazione}

\subsection{Strumenti}

Librerie utilizzate e cose varie, tra queste quelle utilizzate sono:

\begin{itemize}
    \item libcjson: per fare il parsing del file di configurazione scritto in formato json
    \item libcrypto: fornisce le implementazione dei principali schemi crittografici, di hashing e gestione delle chiavi
\end{itemize}

\subsection{Codice}

Il formato dell'header IKE, presente in \textit{Figura \ref{fig:ike-header}}, nel codice \texttt{C}
possiamo tradurlo come una struct


\begin{figure}
    \footnotesize
    \centering
    \begin{Verbatim}[] 
                           1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
      |                   Initiator SPI (64 bits)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
      |                   Responder SPI (64 bits)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
      |  Next Payload |    Version    | Exchange Type |     Flags     |                              
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
      |                     Message ID (32 bits)                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
      |                       Length (32bits)                         | 
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
    \end{Verbatim}
    \caption{Formato IKE Header}
    \label{fig:ike-header}
\end{figure}

\begin{lstlisting} 
    #include <stdio.h> 
    int main() { 
        printf("Hello, World!\n"); 
        return 0; 
    }
\end{lstlisting}
    


Nel parsing della risposta, è stata creata una lookup table. 
Giustificazione dovuta al fatto che la struttura di un pacchetto ike può essere vista come una lista semplicemente puntata
quindi si presta bene ad approcci iterativi. Per questo motivo invece di andare a creare tanti buffer quanti sono i payload si è adottato un approccio diverso

a partire dal buffer del pacchetto si è creata una funzione ricorsiva il cui criterio di stop è quello del next payload nullo (fine della lista), che ad ogni iterazione
si va a "mangiare un pezzo del pacchetto", nel senso che invece che riallocarlo si gioca con i puntatori
una sorta di pacman ma in questo caso il buffer che non consideriamo è ancora esistente, tuttavia questa modalità evita ogni volta di andare a creare e distruggere dei buffer che
sarebbe molto oneroso .

Inoltre è possibile adottare una strategia di buffering pool in cui 

\subsection{Sfide}

%-----------------------------------
%	SECTION 3
%-----------------------------------

\section{Analisi}

%----------------------------------------------------------------------------------------
%	SUBSECTION 2
%----------------------------------------------------------------------------------------

